/**
 * Professional Report Generation for Accessibility Audits
 * 
 * Supports multiple high-quality formats:
 * - ETU Word (.docx) - Professional branded reports with proper document structure
 * - HTML - Semantic, accessible web reports
 * - Markdown - Developer-friendly formatted reports
 * 
 * All formats follow WCAG accessibility guidelines and include:
 * - Proper document structure and headings
 * - Language tagging
 * - Clear visual hierarchy
 * - Remediation recommendations
 * - WCAG compliance scorecard
 */

import { 
  Document, 
  Packer, 
  Paragraph, 
  TextRun,
  HeadingLevel,
  AlignmentType,
  Table,
  TableRow,
  TableCell,
  WidthType,
  BorderStyle,
  PageBreak
} from "docx";

export interface ReportIssue {
  wcag_principle: "Perceivable" | "Operable" | "Understandable" | "Robust";
  success_criterion: string;
  success_criterion_name?: string;
  severity: "critical" | "serious" | "moderate" | "minor";
  description: string;
  element_snippet?: string;
  code_location?: string;
  detection_source: "axe-core" | "ai-heuristic";
  remediation: string;
  wcag_reference_url?: string;
}

export interface AuditData {
  url?: string;
  input_type: "url" | "html_full" | "html_snippet" | "issue_only";
  created_at: string;
  completed_at?: string;
  total_issues: number;
  perceivable_count: number;
  operable_count: number;
  understandable_count: number;
  robust_count: number;
  issues: ReportIssue[];
}

export interface ReportConfig {
  template: "etu-standard" | "etu-detailed" | "etu-summary";
  locale: "sv-SE" | "en-US";
  format: "word" | "html" | "markdown";
  include_ai_summary?: boolean;
  executive_summary?: string;
}

const TRANSLATIONS = {
  "sv-SE": {
    reportTitle: "Tillgänglighetsrapport",
    subtitle: "WCAG 2.2 AA Kompatibilitetsbedömning",
    auditedSource: "Granskad källa:",
    auditDate: "Granskningsdatum:",
    inputType: "Typ av input:",
    totalIssues: "Totalt antal problem:",
    executiveSummary: "Sammanfattning",
    overview: "Översikt",
    overviewIntro: (count: number) => 
      `Denna granskning identifierade ${count} tillgänglighetsproblem organiserade enligt WCAG 2.2 AA:s fyra principer:`,
    perceivable: "Möjlig att uppfatta",
    operable: "Hanterbar",
    understandable: "Begriplig",
    robust: "Robust",
    issuesByPrinciple: "Problem per princip",
    severity: "Allvarlighet:",
    wcagCriterion: "WCAG-kriterium:",
    description: "Beskrivning:",
    remediation: "Åtgärd:",
    element: "Element:",
    complianceScorecard: "Kompatibilitetsöversikt",
    generatedBy: (date: string) => `Genererad av Ally Checker - ${date}`,
  },
  "en-US": {
    reportTitle: "Accessibility Audit Report",
    subtitle: "WCAG 2.2 AA Compliance Assessment",
    auditedSource: "Audited Source:",
    auditDate: "Audit Date:",
    inputType: "Input Type:",
    totalIssues: "Total Issues:",
    executiveSummary: "Executive Summary",
    overview: "Overview",
    overviewIntro: (count: number) => 
      `This audit identified ${count} accessibility issues organized by the four WCAG 2.2 AA principles:`,
    perceivable: "Perceivable",
    operable: "Operable",
    understandable: "Understandable",
    robust: "Robust",
    issuesByPrinciple: "Issues by Principle",
    severity: "Severity:",
    wcagCriterion: "WCAG Criterion:",
    description: "Description:",
    remediation: "Remediation:",
    element: "Element:",
    complianceScorecard: "Compliance Scorecard",
    generatedBy: (date: string) => `Generated by Ally Checker - ${date}`,
  }
};

/**
 * Generate professional Word document (.docx) report
 */
export async function generateWordReport(
  auditData: AuditData,
  config: ReportConfig
): Promise<Buffer> {
  const t = TRANSLATIONS[config.locale];
  const date = new Date(auditData.created_at);
  const formattedDate = date.toLocaleDateString(config.locale, {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  });

  const sections: any[] = [];

  // Title Page
  sections.push({
    children: [
      // Main title
      new Paragraph({
        text: t.reportTitle,
        heading: HeadingLevel.TITLE,
        alignment: AlignmentType.CENTER,
        spacing: { after: 200 },
        run: {
          size: 56, // 28pt
          bold: true,
          color: "003366", // ETU dark blue
        }
      }),
      
      // Subtitle
      new Paragraph({
        text: t.subtitle,
        alignment: AlignmentType.CENTER,
        spacing: { after: 400 },
        run: {
          size: 36, // 18pt
          color: "006699", // ETU medium blue
        }
      }),

      // Metadata Table
      createMetadataTable(auditData, t, formattedDate),

      new Paragraph({ children: [new PageBreak()] }),
    ]
  });

  // Executive Summary (if provided)
  if (config.executive_summary) {
    sections.push({
      children: [
        new Paragraph({
          text: t.executiveSummary,
          heading: HeadingLevel.HEADING_1,
          spacing: { before: 240, after: 120 },
        }),
        new Paragraph({
          text: config.executive_summary,
          spacing: { after: 240 },
        }),
        new Paragraph({ children: [new PageBreak()] }),
      ]
    });
  }

  // Overview Section
  sections.push({
    children: [
      new Paragraph({
        text: t.overview,
        heading: HeadingLevel.HEADING_1,
        spacing: { before: 240, after: 120 },
      }),
      new Paragraph({
        text: t.overviewIntro(auditData.total_issues),
        spacing: { after: 120 },
      }),
      ...createPrincipleBreakdown(auditData, t),
    ]
  });

  // Issues by Principle
  const principles: Array<keyof typeof auditData & string> = [
    'perceivable', 
    'operable', 
    'understandable', 
    'robust'
  ];

  for (const principle of principles) {
    const principleKey = principle.charAt(0).toUpperCase() + principle.slice(1) as ReportIssue['wcag_principle'];
    const issues = auditData.issues.filter(
      issue => issue.wcag_principle === principleKey
    );

    if (issues.length === 0) continue;

    sections.push({
      children: [
        new Paragraph({ children: [new PageBreak()] }),
        new Paragraph({
          text: t[principle as keyof typeof t] as string,
          heading: HeadingLevel.HEADING_1,
          spacing: { before: 240, after: 120 },
        }),
        ...createIssuesList(issues, t, config),
      ]
    });
  }

  // Compliance Scorecard
  sections.push({
    children: [
      new Paragraph({ children: [new PageBreak()] }),
      new Paragraph({
        text: t.complianceScorecard,
        heading: HeadingLevel.HEADING_1,
        spacing: { before: 240, after: 120 },
      }),
      createComplianceTable(auditData, t),
    ]
  });

  // Footer
  sections.push({
    children: [
      new Paragraph({
        text: t.generatedBy(new Date().toLocaleDateString(config.locale)),
        alignment: AlignmentType.CENTER,
        spacing: { before: 400 },
        run: {
          size: 20,
          color: "666666",
        }
      }),
    ]
  });

  const doc = new Document({
    sections: sections.map(section => ({
      properties: {},
      children: section.children
    }))
  });

  return await Packer.toBuffer(doc);
}

function createMetadataTable(
  auditData: AuditData,
  t: typeof TRANSLATIONS["sv-SE"],
  formattedDate: string
): Table {
  return new Table({
    width: { size: 100, type: WidthType.PERCENTAGE },
    borders: {
      top: { style: BorderStyle.SINGLE, size: 1 },
      bottom: { style: BorderStyle.SINGLE, size: 1 },
      left: { style: BorderStyle.SINGLE, size: 1 },
      right: { style: BorderStyle.SINGLE, size: 1 },
    },
    rows: [
      new TableRow({
        children: [
          new TableCell({ children: [new Paragraph({ text: t.auditedSource })] }),
          new TableCell({ children: [new Paragraph({ text: auditData.url || "HTML Input" })] }),
        ]
      }),
      new TableRow({
        children: [
          new TableCell({ children: [new Paragraph({ text: t.auditDate })] }),
          new TableCell({ children: [new Paragraph({ text: formattedDate })] }),
        ]
      }),
      new TableRow({
        children: [
          new TableCell({ children: [new Paragraph({ text: t.inputType })] }),
          new TableCell({ children: [new Paragraph({ text: auditData.input_type })] }),
        ]
      }),
      new TableRow({
        children: [
          new TableCell({ children: [new Paragraph({ text: t.totalIssues })] }),
          new TableCell({ children: [new Paragraph({ text: auditData.total_issues.toString() })] }),
        ]
      }),
    ]
  });
}

function createPrincipleBreakdown(
  auditData: AuditData,
  t: typeof TRANSLATIONS["sv-SE"]
): Paragraph[] {
  const principles = [
    { label: t.perceivable, count: auditData.perceivable_count },
    { label: t.operable, count: auditData.operable_count },
    { label: t.understandable, count: auditData.understandable_count },
    { label: t.robust, count: auditData.robust_count },
  ];

  return principles.map(p => new Paragraph({
    text: `• ${p.label}: ${p.count}`,
    spacing: { after: 60 },
  }));
}

function createIssuesList(
  issues: ReportIssue[],
  t: typeof TRANSLATIONS["sv-SE"],
  config: ReportConfig
): Paragraph[] {
  const paragraphs: Paragraph[] = [];

  issues.forEach((issue, index) => {
    // Issue number and title
    paragraphs.push(new Paragraph({
      text: `${index + 1}. ${issue.success_criterion_name || issue.description.substring(0, 100)}`,
      heading: HeadingLevel.HEADING_2,
      spacing: { before: 200, after: 100 },
    }));

    // WCAG criterion
    paragraphs.push(new Paragraph({
      children: [
        new TextRun({ text: `${t.wcagCriterion} `, bold: true }),
        new TextRun({ text: issue.success_criterion }),
      ],
      spacing: { after: 60 },
    }));

    // Severity
    paragraphs.push(new Paragraph({
      children: [
        new TextRun({ text: `${t.severity} `, bold: true }),
        new TextRun({ 
          text: issue.severity,
          color: getSeverityColor(issue.severity)
        }),
      ],
      spacing: { after: 60 },
    }));

    // Description
    paragraphs.push(new Paragraph({
      children: [new TextRun({ text: t.description, bold: true })],
      spacing: { before: 120, after: 60 },
    }));
    paragraphs.push(new Paragraph({
      text: issue.description,
      spacing: { after: 120 },
    }));

    // Remediation
    paragraphs.push(new Paragraph({
      children: [new TextRun({ text: t.remediation, bold: true })],
      spacing: { after: 60 },
    }));
    paragraphs.push(new Paragraph({
      text: issue.remediation,
      spacing: { after: 120 },
    }));

    // Element (if present)
    if (issue.element_snippet) {
      paragraphs.push(new Paragraph({
        children: [new TextRun({ text: t.element, bold: true })],
        spacing: { after: 60 },
      }));
      paragraphs.push(new Paragraph({
        text: issue.element_snippet,
        spacing: { after: 200 },
        run: {
          font: "Courier New",
          size: 20,
        }
      }));
    }
  });

  return paragraphs;
}

function createComplianceTable(
  auditData: AuditData,
  t: typeof TRANSLATIONS["sv-SE"]
): Table {
  const total = auditData.total_issues;
  const criticalAndSerious = auditData.issues.filter(
    i => i.severity === 'critical' || i.severity === 'serious'
  ).length;

  return new Table({
    width: { size: 100, type: WidthType.PERCENTAGE },
    rows: [
      new TableRow({
        children: [
          new TableCell({ children: [new Paragraph({ text: t.perceivable })] }),
          new TableCell({ children: [new Paragraph({ text: auditData.perceivable_count.toString() })] }),
        ]
      }),
      new TableRow({
        children: [
          new TableCell({ children: [new Paragraph({ text: t.operable })] }),
          new TableCell({ children: [new Paragraph({ text: auditData.operable_count.toString() })] }),
        ]
      }),
      new TableRow({
        children: [
          new TableCell({ children: [new Paragraph({ text: t.understandable })] }),
          new TableCell({ children: [new Paragraph({ text: auditData.understandable_count.toString() })] }),
        ]
      }),
      new TableRow({
        children: [
          new TableCell({ children: [new Paragraph({ text: t.robust })] }),
          new TableCell({ children: [new Paragraph({ text: auditData.robust_count.toString() })] }),
        ]
      }),
    ]
  });
}

function getSeverityColor(severity: string): string {
  const colors = {
    critical: "DC143C",  // Crimson
    serious: "FF6347",   // Tomato
    moderate: "FFA500",  // Orange
    minor: "FFD700",     // Gold
  };
  return colors[severity as keyof typeof colors] || "000000";
}

/**
 * Generate HTML report
 */
export function generateHTMLReport(
  auditData: AuditData,
  config: ReportConfig
): string {
  const t = TRANSLATIONS[config.locale];
  const date = new Date(auditData.created_at).toLocaleDateString(config.locale);

  let html = `<!DOCTYPE html>
<html lang="${config.locale}">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${t.reportTitle}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
      line-height: 1.6;
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem;
      color: #333;
    }
    h1 { color: #003366; border-bottom: 3px solid #006699; padding-bottom: 0.5rem; }
    h2 { color: #006699; margin-top: 2rem; }
    h3 { color: #0099cc; }
    table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
    th, td { padding: 0.75rem; text-align: left; border: 1px solid #ddd; }
    th { background-color: #f8f9fa; font-weight: 600; }
    .severity { padding: 0.25rem 0.5rem; border-radius: 4px; font-weight: 600; }
    .severity-critical { background-color: #dc143c; color: white; }
    .severity-serious { background-color: #ff6347; color: white; }
    .severity-moderate { background-color: #ffa500; color: white; }
    .severity-minor { background-color: #ffd700; color: #333; }
    code { background: #f5f5f5; padding: 0.2rem 0.4rem; border-radius: 3px; font-family: 'Courier New', monospace; }
    pre { background: #f5f5f5; padding: 1rem; border-radius: 4px; overflow-x: auto; }
  </style>
</head>
<body>
  <header>
    <h1>${t.reportTitle}</h1>
    <p>${t.subtitle}</p>
  </header>

  <section>
    <table>
      <tr><th>${t.auditedSource}</th><td>${auditData.url || 'HTML Input'}</td></tr>
      <tr><th>${t.auditDate}</th><td>${date}</td></tr>
      <tr><th>${t.totalIssues}</th><td>${auditData.total_issues}</td></tr>
    </table>
  </section>`;

  if (config.executive_summary) {
    html += `
  <section>
    <h2>${t.executiveSummary}</h2>
    <p>${config.executive_summary}</p>
  </section>`;
  }

  html += `
  <section>
    <h2>${t.overview}</h2>
    <p>${t.overviewIntro(auditData.total_issues)}</p>
    <ul>
      <li>${t.perceivable}: ${auditData.perceivable_count}</li>
      <li>${t.operable}: ${auditData.operable_count}</li>
      <li>${t.understandable}: ${auditData.understandable_count}</li>
      <li>${t.robust}: ${auditData.robust_count}</li>
    </ul>
  </section>`;

  // Issues by principle
  const principles: Array<[string, ReportIssue['wcag_principle']]> = [
    [t.perceivable, 'Perceivable'],
    [t.operable, 'Operable'],
    [t.understandable, 'Understandable'],
    [t.robust, 'Robust'],
  ];

  principles.forEach(([label, principle]) => {
    const issues = auditData.issues.filter(i => i.wcag_principle === principle);
    if (issues.length === 0) return;

    html += `\n  <section>\n    <h2>${label}</h2>`;
    
    issues.forEach((issue, index) => {
      html += `
    <article>
      <h3>${index + 1}. ${issue.success_criterion_name || issue.description.substring(0, 100)}</h3>
      <p><strong>${t.wcagCriterion}</strong> ${issue.success_criterion}</p>
      <p><strong>${t.severity}</strong> <span class="severity severity-${issue.severity}">${issue.severity}</span></p>
      <p><strong>${t.description}</strong><br>${issue.description}</p>
      <p><strong>${t.remediation}</strong><br>${issue.remediation}</p>
      ${issue.element_snippet ? `<p><strong>${t.element}</strong><br><code>${escapeHtml(issue.element_snippet)}</code></p>` : ''}
    </article>`;
    });

    html += `\n  </section>`;
  });

  html += `
  <footer>
    <p>${t.generatedBy(new Date().toLocaleDateString(config.locale))}</p>
  </footer>
</body>
</html>`;

  return html;
}

function escapeHtml(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

/**
 * Generate Markdown report
 */
export function generateMarkdownReport(
  auditData: AuditData,
  config: ReportConfig
): string {
  const t = TRANSLATIONS[config.locale];
  const date = new Date(auditData.created_at).toLocaleDateString(config.locale);

  let md = `# ${t.reportTitle}\n\n`;
  md += `## ${t.subtitle}\n\n`;
  md += `**${t.auditedSource}** ${auditData.url || 'HTML Input'}  \n`;
  md += `**${t.auditDate}** ${date}  \n`;
  md += `**${t.totalIssues}** ${auditData.total_issues}\n\n`;

  if (config.executive_summary) {
    md += `## ${t.executiveSummary}\n\n${config.executive_summary}\n\n`;
  }

  md += `## ${t.overview}\n\n`;
  md += `${t.overviewIntro(auditData.total_issues)}\n\n`;
  md += `- ${t.perceivable}: ${auditData.perceivable_count}\n`;
  md += `- ${t.operable}: ${auditData.operable_count}\n`;
  md += `- ${t.understandable}: ${auditData.understandable_count}\n`;
  md += `- ${t.robust}: ${auditData.robust_count}\n\n`;

  const principles: Array<[string, ReportIssue['wcag_principle']]> = [
    [t.perceivable, 'Perceivable'],
    [t.operable, 'Operable'],
    [t.understandable, 'Understandable'],
    [t.robust, 'Robust'],
  ];

  principles.forEach(([label, principle]) => {
    const issues = auditData.issues.filter(i => i.wcag_principle === principle);
    if (issues.length === 0) return;

    md += `\n## ${label}\n\n`;
    
    issues.forEach((issue, index) => {
      md += `### ${index + 1}. ${issue.success_criterion_name || issue.description.substring(0, 100)}\n\n`;
      md += `**${t.wcagCriterion}** ${issue.success_criterion}  \n`;
      md += `**${t.severity}** ${issue.severity}  \n\n`;
      md += `**${t.description}**  \n${issue.description}\n\n`;
      md += `**${t.remediation}**  \n${issue.remediation}\n\n`;
      if (issue.element_snippet) {
        md += `**${t.element}**  \n\`\`\`html\n${issue.element_snippet}\n\`\`\`\n\n`;
      }
      md += `---\n\n`;
    });
  });

  md += `\n---\n\n${t.generatedBy(new Date().toLocaleDateString(config.locale))}\n`;

  return md;
}
